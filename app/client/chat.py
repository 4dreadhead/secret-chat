# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt6 UI code generator 6.4.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
from queue import Queue
import datetime
from PyQt6 import QtCore, QtGui, QtWidgets
from .login_form import LoginForm
from .models import User, Message


class Chat(QtWidgets.QMainWindow, object):
    TICK_INTERVAL = 500

    def __init__(self):
        super().__init__()
        self.online_users_list = []
        self.messages_list = []
        self.current_user = None
        self.queue_in = Queue()
        self.queue_out = Queue()
        self.connection_thread = None
        self.online_users_list = []
        self.authorized = False
        self.timer = QtCore.QTimer()
        self.setupUi(self)
        self.retranslateUi(self)

    def closeEvent(self, event):
        self.queue_out.put(
            {
                "method": "logout"
            }
        )

        if self.connection_thread:
            self.connection_thread = None

        event.accept()

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1108, 570)
        MainWindow.setMaximumSize(1108, 570)
        MainWindow.setMinimumSize(760, 570)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.new_message = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.new_message.setGeometry(QtCore.QRect(20, 450, 531, 101))
        self.new_message.setObjectName("textEdit")

        self.send_message = QtWidgets.QPushButton(self.centralwidget)
        self.send_message.setGeometry(QtCore.QRect(560, 450, 191, 51))
        self.send_message.setObjectName("pushButton")

        self.select_file = QtWidgets.QPushButton(self.centralwidget)
        self.select_file.setGeometry(QtCore.QRect(560, 510, 91, 41))
        self.select_file.setObjectName("pushButton_2")

        self.get_hash = QtWidgets.QPushButton(self.centralwidget)
        self.get_hash.setGeometry(QtCore.QRect(660, 510, 91, 41))
        self.get_hash.setObjectName("pushButton_3")

        self.online_users = QtWidgets.QListWidget(self.centralwidget)
        self.online_users.setGeometry(QtCore.QRect(770, 60, 321, 251))
        self.online_users.setObjectName("listWidget")

        self.session_key = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.session_key.setGeometry(QtCore.QRect(770, 330, 321, 101))
        self.session_key.setObjectName("plainTextEdit")

        self.hash = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.hash.setGeometry(QtCore.QRect(770, 450, 321, 101))
        self.hash.setObjectName("plainTextEdit_2")

        self.login = QtWidgets.QPushButton(self.centralwidget)
        self.login.setGeometry(QtCore.QRect(940, 10, 151, 31))
        self.login.setObjectName("pushButton_4")

        self.status = QtWidgets.QLabel(self.centralwidget)
        self.status.setGeometry(QtCore.QRect(770, 10, 151, 31))
        self.status.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.status.setObjectName("textBrowser")

        self.messages = QtWidgets.QListWidget(self.centralwidget)
        self.messages.setGeometry(QtCore.QRect(20, 10, 731, 421))
        self.messages.setObjectName("listWidget_2")

        MainWindow.setCentralWidget(self.centralwidget)
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.login.clicked.connect(self.open_login_form)
        self.send_message.clicked.connect(self.send)
        self.timer.timeout.connect(self.check_queue)
        self.timer.start(self.TICK_INTERVAL)

    def set_online_user(self, user):
        item = QtWidgets.QListWidgetItem()
        item.username = user

        widget = QtWidgets.QWidget()
        widget_text = QtWidgets.QLabel(user.login)
        widget_text.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        widget_layout = QtWidgets.QHBoxLayout()
        widget_layout.addWidget(widget_text)
        widget_layout.addStretch()

        # widget_layout.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetFixedSize)
        widget.setLayout(widget_layout)
        item.setSizeHint(widget.sizeHint())

        self.online_users.addItem(item)
        self.online_users.itemClicked.connect(self.select_user)
        self.online_users.setItemWidget(item, widget_text)

    def set_message(self, from_user, message, sent_at):
        item = QtWidgets.QListWidgetItem()
        item.username = from_user

        widget = QtWidgets.QWidget()
        widget_user = QtWidgets.QLabel(f"[ {from_user} ]  [ {sent_at} ]")
        widget_message = QtWidgets.QLabel(message)
        widget_layout = QtWidgets.QVBoxLayout()
        widget_layout.addWidget(widget_user, stretch=1)
        widget_layout.addWidget(widget_message, )

        if from_user == self.me.login:
            widget_user.setAlignment(QtCore.Qt.AlignmentFlag.AlignRight)
            widget_message.setAlignment(QtCore.Qt.AlignmentFlag.AlignRight)
        else:
            widget_user.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)
            widget_message.setAlignment(QtCore.Qt.AlignmentFlag.AlignLeft)

        widget_layout.addStretch()
        widget.setLayout(widget_layout)
        item.setSizeHint(widget.sizeHint())

        self.messages.addItem(item)
        self.messages.setItemWidget(item, widget)
        self.messages.scrollToBottom()

    def select_user(self, item):
        if not self.authorized:
            return

        if self.current_user == item.username:
            return

        self.switch_to_user(item.username)

    def switch_to_user(self, user):
        self.current_user = user
        self.messages.clear()
        for message in user.messages:
            self.set_message(message.from_user, message.text, message.sent_at)

        print(f"Switching to user {user}")

    def open_login_form(self):
        if self.authorized:
            self.online_users.clear()
            self.messages.clear()

            self.queue_out.put(
                {
                    "method": "logout"
                }
            )

            if self.connection_thread:
                self.connection_thread = None

            # self.queue_in.queue.clear()
            # self.queue_out.queue.clear()

            self.status.setText("Вы не авторизованы")
            self.login.setText("Войти")

            self.current_user = None
            self.authorized = False

        else:
            self.login_form = LoginForm(self)
            self.login_form.show()

    def check_queue(self, max_tasks_per_iteration=3):
        if self.queue_in is None or self.queue_out is None:
            return

        for _ in range(max_tasks_per_iteration):
            if self.queue_in.empty():
                break

            payload = self.queue_in.get()
            self.handle_task(payload)
            self.queue_in.task_done()

        self.timer.start(self.TICK_INTERVAL)

    def send(self):
        if not self.authorized:
            return

        message = Message(
            self.me.login,
            self.current_user.login,
            self.new_message.toPlainText(),
            datetime.datetime.now().strftime("%d.%m.%y %H:%M")
        )

        if not message.text:
            return

        self.set_message(message.from_user, message.text, message.sent_at)

        self.queue_out.put(
            {
                "method": "send_message",
                "username": message.to_user,
                "message": message.text
            }
        )
        self.current_user.add_message(message)
        self.new_message.clear()

    def handle_task(self, payload):
        match payload["method"]:
            case "userdata":
                self.set_user_data_to_session(payload)
            case "close_connection":
                self.send_close_connection()
            case "user_joined":
                self.set_new_user(payload)
            case "user_left":
                self.remove_left_user(payload)
            case "new_message":
                self.set_new_message(payload)

    def set_user_data_to_session(self, payload):
        self.online_users_list = list(map(User, payload["online_users"]))
        messages = [(f[1], f[2], f[3], f[4]) for f in payload["messages"]]
        self.messages_list = list(map(lambda x: Message(*x), messages))

        self.authorized = True
        self.me = User(payload["login"])
        self.login.setText("Выйти")
        self.status.setText(self.me.login)
        self.session_key.setPlainText(payload["session_key"])

        for user in self.online_users_list:
            self.set_online_user(user)
            for message in self.messages_list:
                self.add_message_to_user(message, user)
        self.current_user = self.online_users_list[0]

        for message in self.current_user.messages:
            self.set_message(message.from_user, message.text, message.sent_at)

        if self.login_form:
            self.login_form.close()
            self.login_form = None

    def send_close_connection(self):
        self.online_users.clear()
        self.messages.clear()

        if self.login_form:
            self.login_form.close()
            self.login_form = None

            self.queue_out.put({"method": "logout"})

        if self.connection_thread:
            self.connection_thread = None

        self.authorized = False

    def set_new_user(self, payload):
        user = User(payload["username"])
        self.online_users_list.append(user)
        self.set_online_user(user)
        for message in self.messages_list:
            self.add_message_to_user(message, user)

    def remove_left_user(self, payload):
        user_to_remove = None

        for user in self.online_users_list:
            if payload["username"] == user.login:
                self.online_users_list.remove(user)
                user_to_remove = user

        for i in range(self.online_users.count()):
            if user_to_remove == self.online_users.item(i).username:
                self.online_users.takeItem(i)
                break

    def set_new_message(self, payload):
        print("new message")
        if payload["from_user"] == self.me.login:
            return

        new_message = Message(payload["from_user"], self.me.login, payload["message"], payload["sent_at"])
        self.messages_list.append(new_message)
        for user in self.online_users_list:
            if user.login == payload["from_user"]:
                user.add_message(new_message)
                if self.current_user == user:
                    self.set_message(user.login, new_message.text, new_message.sent_at)

    def add_message_to_user(self, message, user):
        if message.from_user == self.me.login == user.login != message.to_user:
            return
        elif message.from_user == user.login and message.to_user != user.login:
            user.add_message(message)
        elif message.from_user == self.me.login and message.to_user == user.login and self.me.login != user.login:
            user.add_message(message)
        elif message.from_user == message.to_user == user.login:
            user.add_message(message)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.send_message.setText(_translate("MainWindow", "Отправить"))
        self.select_file.setText(_translate("MainWindow", "Файл"))
        self.get_hash.setText(_translate("MainWindow", "Хэш"))
        self.login.setText(_translate("MainWindow", "Войти"))
        self.status.setText("Вы не авторизованы")
